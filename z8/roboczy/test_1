nclude <stdio.h>
#include <stdlib.h>

nt                                                                          
read(FILE * p, double v[], int max_l_e)                                      
{                                                                            
        int             n, i;   /* zmienne robocze */                        

        if (fscanf(p, "%i", &n) != 1 || n <= 0 || n > max_l_e) {        /* probujemy przeczytac
                                                                         * liczbe elementow */
                /*
                 * nie udalo sie (fscanf zwrocila wartosc inna niz 1 lub
                 * wczytana wartosc jest niedodatnia albo zbyt duza )
                 */
                return -1;
        }
        while ((i = fgetc(p)) == ' ')   /* pomijamy spacje po liczbie
                                         * elementow */
                ;

        /* mamy znak rozny od spacji - powinien to byc znak '[' */
        if (i != '[')
                return -2;      /* nie jest - bledny format pliku */
        /* teraz czytamy n liczb */

	i=0;
        while ( i < n){
               if (fscanf(p, "%lf", &(v[i])) != 1)
			return -3;
		i++;
	}      /*fscanf powinno zawsze

                                                         * zwracac 1 - jesli
                                                         * zwroci cos innego */
                              /* to znaczy, ze format pliku jest
                                         * zly */

        /* mamy liczby, teraz szukamy zamykajacego nawiasu: */

        while ((i = fgetc(p)) == ' ')   /* pomijamy spacje */
                ;
        /* mamy znak rozny od spacji - powinien to byc znak ']' */
        if (i != ']')
                return -4;      /* nie jest - bledny format pliku */

        /*
         * jesli doszlismy juz tu, to wszystko jest ok, mamy w wektorze n
         * liczb
         */
        return n;
}
/*
 * L2: oblicza norme L2 (pierwiastek z sumy kwadratow) wektora double v[] o
 * dlugosci n
 */
void                                                                          
write(FILE * p, double v[], int n)                                      
{                                                                            

	fprintf(p,"%i [ ", n);
	 int i=0;
	 while( i < n){
         	fprintf(p, "%lf ", (v[i]));
		i++;
	}      /* fscanf powinno zawsze
                                                         * zwracac 1 - jesli
                                                         * zwroci cos innego */      /* to znaczy, ze format pliku jest
                                         * zly */

        /* mamy liczby, teraz szukamy zamykajacego nawiasu: */

        /* mamy znak rozny od spacji - powinien to byc znak ']' */
        fprintf(p, "]\n");      /* nie jest - bledny format pliku */

        /*
         * jesli doszlismy juz tu, to wszystko jest ok, mamy w wektorze n
         * liczb
         */
        return ;
}
double
L2(double v[], int n)
{
        int             i;
        double             l2 = 0; /* wazne jest, aby nadac l2 wartosc
                                 * poczatkowa */
        for (i = 0; i < n; i++)
                l2 += v[i] * v[i];
        return sqrt(l2);
}

/*
 * dot_product: oblicza iloczyn skalarny wektorow double v[] i u[] v i u maja
 * dlugosc n
 */
double
dot_product(double v[], double u[], int n)
{
        int             i;
        double           dp = 0; /* wazne jest, aby nadac dp wartosc
                                 * poczatkowa */
        for (i = 0; i < n; i++)
                dp += v[i] * u[i];
        return dp;
}
void
max_wekt(double v1[], double v2[],double v[], int n1, int n2){
	if(n1 != n2){
		printf("Zle! n1=%i, a n2=%i.\n", n1, n2);
		return ;
	}
	int i=0;
	while(i<n1){
		if(v1[i]>v2[i])
			v[i]=v1[i];
		else
			v[i]=v2[i];
		i++;
	}
	return ;
}  



int
main(int argc, char *argv[])
{
        double           w_1[10];
        double           w_2[10];
	double		 w[10];
        int             n1;
        int             n2;
        int             i;
	char		c[3];
	
	char 		*funkcja = argc > 1 ? argv[1] : "max";
	if(strcmp(funkcja, "L2") == 0 ){	
		
        	FILE            *we1 = argc > 2 ? fopen(argv[2], "r") : stdin;
		FILE		*wy = argc > 3 ? fopen(argv[3], "w") : stdout;    /* jesli argc > 1 to
                                                                         * program zostal
                                                                         * wywolany z argumentem
                                                                         * - probujemy otworzyc
                                                                         * taki plik do czytania */
        	if (we1 == NULL) {       /* stdin != NULL, a wiec to mozliwe tylko,
                                 * gdy argv[1] zawiera cos, co nie jest nazwa
                                 * istniejacego pliku */
                	fprintf(stderr, "Plik wejsciowy %s nie istnieje!\n", argv[1]);
                	exit(1);
        	}
        	n1 = read(we1, w_1, 10);   /* czytamy z wejscia wektor i pakujemy go
        	                         * do w_1 */
	
        	if (n1 > 0) {
        	        printf("Wczytano %i-elementowy wektor:\n( ", n1);
               		for (i = 0; i < n1; i++)
                        	printf("%f ", w_1[i]);
                	printf(")\n");
        	} else {
                	fprintf(stderr, "Wystapil blad przy wczytywaniu wektora: kod bledu=%i\n", n1);
                	return 1;
        	}
        	fprintf(wy,"Norma L2 wczytanego wektora = %f\n", L2(w_1, n1));
		
   /* czytamy z wejscia wektor i pakujemy go
                                 * do w_2 */
		return 0;
	}else {
	
        	FILE            *we1 = argc > 2 ? fopen(argv[2], "r") : stdin;
		FILE		*we2 = argc > 3 ? fopen(argv[3], "r") : stdin;
		FILE		*wy = argc > 4 ? fopen(argv[4], "w") : stdout;    /* jesli argc > 1 to
                                                                         * program zostal
                                                                         * wywolany z argumentem
                                                                         * - probujemy otworzyc
                                                                         * taki plik do czytania */
        	if (we1 == NULL || we2 == NULL) {       /* stdin != NULL, a wiec to mozliwe tylko,
                                 * gdy argv[1] zawiera cos, co nie jest nazwa
                                 * istniejacego pliku */
        	        fprintf(stderr, "Plik wejsciowy %s nie istnieje!\n", argv[1]);
        	        exit(1);
       		}
        	n1 = read(we1, w_1, 10);
		n2 = read(we2, w_2, 10);   /* czytamy z wejscia wektor i pakujemy go
        	                         * do w_1 */

        	if (n1 > 0) {
        	        printf("Wczytano %i-elementowy wektor:\n( ", n1);
        	        for (i = 0; i < n1; i++)
        	                printf("%f ", w_1[i]);
        	        printf(")\n");
        	} else {
        	        fprintf(stderr, "Wystapil blad przy wczytywaniu wektora: kod bledu=%i\n", n1);
        	        return 1;
        	}
			
   /* czytamy z wejscia wektor i pakujemy go
                                 * do w_2 */

        	if (n2 > 0) {
        	        printf("Wczytano %i-elementowy wektor:\n( ", n2);
        	        for (i = 0; i < n2; i++)
        	                printf("%f ", w_2[i]);
        	        printf(")\n");
        	} else {
        	        fprintf(stderr, "Wystapil blad przy wczytywaniu wektora: kod bledu=%i\n", n2);
        	        return 1;
        	}
	
        // printf("Norma L2 wczytanego wektora = %f\n", L2(w_2, n2));
		if (strcmp(funkcja, "dot") == 0){
        		if ( n1 == n2 ) {
        	        	fprintf(wy, "Iloczyn skalarny wczytanych wektorow = %f\n", dot_product(w_1, w_2, n1));
        		} else {
        		        fprintf(wy, "Wczytane wektory maja rozna dlugosci i nie mozna ich pomnozyc przez siebie\n" );
        		return 2;
			}
		}
		if(strcmp(funkcja, "max") == 0){
			max_wekt(w_1,w_2,w,n1,n2);
			write(wy,w,n1);
		}
		return 0;
	}
}
